#include <MEII/Control/DynamicMotionPrimitive.hpp>
#include <MEII/Control/MinimumJerk.hpp>
#include <MEII/Control/Trajectory.hpp>
#include <MEII/MahiExoII/MahiExoII.hpp>
#include <MEL/Communications/MelShare.hpp>
#include <MEL/Core/Console.hpp>
#include <MEL/Core/Timer.hpp>
#include <MEL/Daq/Quanser/Q8Usb.hpp>
#include <MEL/Devices/Windows/Keyboard.hpp>
#include <MEL/Logging/Csv.hpp>
#include <MEL/Logging/Log.hpp>
#include <MEL/Math/Functions.hpp>
#include <MEL/Math/Integrator.hpp>
#include <MEL/Utility/Options.hpp>
#include <MEL/Utility/System.hpp>
#include <vector>
#include <chrono>
#include <ctime>

using namespace mel;
using namespace meii;

enum state {
    rps_init,   // 0
    to_start,   // 1
    start_wait, // 2
    trajectory, // 3
    end_wait    // 4
};

enum dof {
    elbow_fe,   // 0
    forearm_ps, // 1
    wrist_fe,   // 2
    wrist_ru    // 3
};

// create global stop variable CTRL-C handler function
ctrl_bool stop(false);
bool handler(CtrlEvent event) {
    stop = true;
    return true;
}

void to_state(state& current_state_, const int next_state_, Clock& ref_traj_clock_) {
    
    // iterate the state. can't iterate an enum, so this iterates
    current_state_ = static_cast<state>(next_state_);

    // restart the trajectory clock
    ref_traj_clock_.restart();
}

void generate_singledof_trajectory(std::vector<Trajectory>& single_dof_trajectories_, std::vector<Time>& all_times_, std::vector<dof>& dof_order, dof dof_, std::vector<Time> traj_time_, std::vector<double> traj_pos_, std::vector<double> max_diff_){
    if(traj_time_[0] != Time::Zero || traj_time_.size() != traj_pos_.size()){
        LOG(Error) << "Incorrect parameters for inputs. Returning false.";
        stop = true;
    }
    std::vector<WayPoint> waypoints;
    for (auto i = 0; i < traj_time_.size(); i++){
        if(!std::count(all_times_.begin(),all_times_.end(),traj_time_[i])){
            all_times_.push_back(traj_time_[i]);
        }
        waypoints.push_back(WayPoint(traj_time_[i],{traj_pos_[i] * mel::DEG2RAD}));
    }    
    sort(all_times_.begin(), all_times_.end());
    
    Trajectory new_traj(1, waypoints, Trajectory::Interp::Linear, {max_diff_[dof_]});
    if (!new_traj.validate()) {
        LOG(Warning) << "single dof trajectory invalid.";
        stop = true;
    }

    dof_order.push_back(dof_);
    single_dof_trajectories_.push_back(new_traj);
}

Trajectory combine_trajectories(std::vector<Trajectory> single_dof_trajs, std::vector<dof> dof_order_, WayPoint default_positions_, std::vector<Time> times_, std::vector<double> max_diff_, std::vector<WayPoint> &waypoints){
    
    for (auto i = 0; i < times_.size(); i++){
        std::vector<double> positions = default_positions_.get_pos();

        for (auto j = 0; j < dof_order_.size(); j++){
            dof dof_ = dof_order_[j];
            positions[dof_] = single_dof_trajs[dof_].at_time(times_[i])[0];
        }
        waypoints.push_back(WayPoint(times_[i],positions));
    }
    
    Trajectory new_traj(default_positions_.get_pos().size(), waypoints, Trajectory::Interp::Linear, max_diff_);
    if (!new_traj.validate()) {
        LOG(Warning) << "full trajectory invalid.";
        stop = true;
    }

    return new_traj;
}

int main(int argc, char* argv[]) {
    // register ctrl-c handler
    register_ctrl_handler(handler);

    // make options
    Options options("ex_pos_control_nathan.exe", "Nathan's Position Control Demo");
    options.add_options()
		("c,calibrate", "Calibrates the MAHI Exo-II")
		("m,multi", "MAHI Exo-II follows a multi-DoF trajectory generated by mjs")
        ("n,no_torque", "trajectories are generated, but not torque provided")
		("h,help", "Prints this help message");

    auto result = options.parse(argc, argv);

    // if -h, print the help option
    if (result.count("help") > 0) {
        print(options.help());
        return 0;
    }

    /////////////////////////////////
    // construct Q8 USB and configure
    /////////////////////////////////
    Q8Usb q8;
    q8.open();
    q8.DO.set_enable_values(std::vector<Logic>(8, High));
    q8.DO.set_disable_values(std::vector<Logic>(8, High));
    q8.DO.set_expire_values(std::vector<Logic>(8, High));

    Time Ts = milliseconds(1);  // sample period for DAQ

    ////////////////////////////////

    //////////////////////////////////////////////
    // create MahiExoII and bind Q8 channels to it
    //////////////////////////////////////////////

    std::vector<Amplifier> amplifiers;
    for (uint32 i = 0; i < 2; ++i) {
        amplifiers.push_back(
            Amplifier("meii_amp_" + std::to_string(i),
                      Low,
                      q8.DO[i + 1],
                      1.8,
                      q8.AO[i + 1]));
    }
    for (uint32 i = 2; i < 5; ++i) {
        amplifiers.push_back(
            Amplifier("meii_amp_" + std::to_string(i),
                      Low,
                      q8.DO[i + 1],
                      0.184,
                      q8.AO[i + 1]));
    }
    MeiiConfiguration config(q8, q8.watchdog, q8.encoder[{1, 2, 3, 4, 5}], amplifiers);
    MahiExoII meii(config);

    bool rps_is_init = false;

    //////////////////////////////////////////////

    // calibrate - manually zero the encoders (right arm supinated)
    if (result.count("calibrate") > 0) {
        meii.calibrate_auto(stop);
        LOG(Info) << "MAHI Exo-II encoders calibrated.";
        return 0;
    }

    // initialize double vectors for collecting data
    std::vector<std::string> log_header = {"Time (s)", 
                                            "anat_pos_1", "anat_pos_2", "anat_pos_3", "anat_pos_4", "anat_pos_5",
                                            "cmd_torq_1", "cmd_torq_2", "cmd_torq_3", "cmd_torq_4", "cmd_torq_5",
                                            "robo_pos_1", "robo_pos_2", "robo_pos_3", "robo_pos_4", "robo_pos_5",
                                            "anat_vel_1", "anat_vel_2", "anat_vel_3", "anat_vel_4", "anat_vel_5",
                                            "robo_vel_1", "robo_vel_2", "robo_vel_3", "robo_vel_4", "robo_vel_5"};
    std::vector<double> aj_positions = {0.0, 0.0, 0.0, 0.0, 0.0};
    std::vector<double> rj_positions = {0.0, 0.0, 0.0, 0.0, 0.0};
    std::vector<double> aj_velocities = {0.0, 0.0, 0.0, 0.0, 0.0};
    std::vector<double> rj_velocities = {0.0, 0.0, 0.0, 0.0, 0.0};
    std::vector<std::vector<double>> robot_log;

    // get current timestamp
    time_t rawtime;
    struct tm * timeinfo;
    char buffer[80];
    time (&rawtime);
    timeinfo = localtime(&rawtime);
    strftime(buffer,sizeof(buffer),"%d_%m_%Y_%H_%M_%S",timeinfo);
    std::string time_string(buffer);

    std::string filepath = "../data/fes_test/Multi_dof_" + time_string + ".csv";
    std::string filepath_waypoint = "../data/fes_test/Multi_dof_waypoint_" + time_string + ".csv";

    // Code to create trajectories
    std::vector<Trajectory> single_dof_trajectories;
    std::vector<Time> all_times;
    std::vector<dof> dof_order;
    std::vector<WayPoint> full_waypoints;

    WayPoint neutral_point = WayPoint(Time::Zero, {-35 * DEG2RAD,  00 * DEG2RAD, 00  * DEG2RAD, 00 * DEG2RAD, 0.11});

    std::vector<double> traj_max_diff = { 50 * mel::DEG2RAD, 50 * mel::DEG2RAD, 25 * mel::DEG2RAD, 25 * mel::DEG2RAD, 0.1 };

    generate_singledof_trajectory(single_dof_trajectories, all_times, dof_order, elbow_fe,  {Time::Zero, seconds(3.0), seconds(5.0), seconds(10.0), seconds(12.0)}, 
                                                                                            {-75.0,      -75.0,        -5.0,         -5.0,         -75.0},       traj_max_diff);

    generate_singledof_trajectory(single_dof_trajectories, all_times, dof_order, forearm_ps,{Time::Zero, seconds(4.0), seconds(6.0), seconds(8.0), seconds(8.0)}, 
                                                                                            {0.0,      0.0,           -45.0,         -45.0,         0.0},       traj_max_diff);

    // generate_singledof_trajectory(single_dof_trajectories, all_times, dof_order, forearm_ps,{Time::Zero, seconds(2.0), seconds(4.0), seconds(6.0)}, 
    //                                                                                         {0.0,      0.0,          0.0,         0.0},       traj_max_diff);

    generate_singledof_trajectory(single_dof_trajectories, all_times, dof_order, wrist_fe,  {Time::Zero, seconds(4.5), seconds(5.5), seconds(8.0), seconds(9.0)}, 
                                                                                            {0.0,        0.0,          20.0,         20.0,       0.0},       traj_max_diff);

    Trajectory full_traj = combine_trajectories(single_dof_trajectories, dof_order, neutral_point, all_times, traj_max_diff, full_waypoints);

    // print(full_traj.at_time(seconds(4.98))[0]);
    // print(full_traj.at_time(seconds(5.0))[0]);

    // print(full_traj.at_time(seconds(4.98))[1]);
    // print(full_traj.at_time(seconds(5.0))[1]);

    Time to_start_time = seconds(5.0);

    WayPoint start_pos(to_start_time,full_traj.at_time(Time::Zero));

    std::vector<Time> state_times = {seconds(1000.0), to_start_time, seconds(1000.0), full_traj.back().when(), seconds(1000.0)};

    // construct clock for regulating keypress
    Clock keypress_refract_clock;
    Time keypress_refract_time = seconds(0.5);

    // make MelShares
    MelShare ms_pos("ms_pos");
    MelShare ms_vel("ms_vel");
    MelShare ms_trq("ms_trq");
    MelShare ms_ref("ms_ref");

    // create ranges for saturating trajectories for safety  MIN            MAX
    std::vector<std::vector<double>> setpoint_rad_ranges = {{-90 * DEG2RAD, 0 * DEG2RAD},
                                                            {-90 * DEG2RAD, 90 * DEG2RAD},
                                                            {-10 * DEG2RAD, 10 * DEG2RAD},
                                                            {-10 * DEG2RAD, 10 * DEG2RAD},
                                                            {0.08, 0.115}};

    // setup variables needed to generate trajectories

    // initialize reference trajectory
    std::vector<double> ref(meii.N_aj_,0.0);

    // construct timer in hybrid mode to avoid using 100% CPU
    Timer timer(Ts, Timer::Hybrid);
    timer.set_acceptable_miss_rate(0.05);

    std::vector<std::string> dof_str = {"ElbowFE", "WristPS", "WristFE", "WristRU"};

    ////////////////////////////////////////////////
    //////////// State Manager Setup ///////////////
    ////////////////////////////////////////////////

    // initialize to the first state
    state current_state = rps_init;

    // initialize the minimum jerk trajectory and trajectory clock
    Time mj_Ts = milliseconds(20);
    MinimumJerk mj(mj_Ts, neutral_point, start_pos);
	
	mj.set_trajectory_params(Trajectory::Interp::Linear, traj_max_diff);

    Clock ref_traj_clock;
    

    // print(mj.trajectory().at_time(seconds(5.0))[1]); // THIS LINE SHOULDNT BE NEEDED...BUT IT IS IN HERE OR ELSE IT FAILS
    // mj.trajectory().at_time(seconds(5.0))[1]);
    // if (!mj.trajectory().validate()) {
    //     LOG(Warning) << "MJ trajectory invalid.";
    //     // stop = true;
    // }

    // initialize command torque vectors
    std::vector<double> command_torques(meii.N_aj_,0.0);
    std::vector<double> rps_command_torques(3,0.0);
	
	// enable DAQ and exo
	q8.enable();
	meii.enable();
	
	q8.watchdog.start();

    // trajectory following
    if (result.count("multi") > 0 || result.count("no_torque") > 0) {
        LOG(Info) << "Initializing RPS Mechanism.";

        // update q8 values so that we can get meii kinematic values
        q8.update_input();

        // update MahiExoII kinematics
        meii.update_kinematics();

        // start rps initialization
        meii.rps_init_par_ref_.start(meii.get_wrist_parallel_positions(), timer.get_elapsed_time());

        // start the reference trajectory clock
        ref_traj_clock.restart();

        while (!stop) {
            
            // update all DAQ input channels
            q8.update_input();

            // update MahiExoII kinematics
            meii.update_kinematics();

            // update anatomical positions and velocities
            for (int i = 0; i < meii.N_aj_; ++i) {
                aj_positions[i] = meii.get_anatomical_joint_position(i);
                aj_velocities[i] = meii.get_anatomical_joint_velocity(i);
            }
            rj_positions = meii.get_joint_positions();
            rj_velocities = meii.get_joint_velocities();

            // choose how we are updating ref based on what state we are in
            switch(current_state) {
                case rps_init:
                    ref = meii.get_anatomical_joint_positions();
                    break;
                case to_start:
                    // update reference from trajectory
                    ref = mj.trajectory().at_time(ref_traj_clock.get_elapsed_time());
                    break;
                case start_wait:
                    ref = mj.trajectory().back().get_pos();
                    break;
                case trajectory:
                    ref = full_traj.at_time(ref_traj_clock.get_elapsed_time());
                    break;
                case end_wait:
                    ref = full_traj.back().get_pos();
                    break;
            }

            // constrain trajectory to be within range
            for (std::size_t i = 0; i < meii.N_aj_; ++i) {
                ref[i] = saturate(ref[i], setpoint_rad_ranges[i][0], setpoint_rad_ranges[i][1]);
            }

            if (current_state == rps_init){
                command_torques[0] = 0.0; //elbow
                command_torques[1] = 0.0; //forearm
                
                if(!meii.check_rps_init()){
                    // set rps_command torques to move at a fixed speed towards safe initialization
                    rps_command_torques = meii.set_rps_pos_ctrl_torques(meii.rps_init_par_ref_, timer.get_elapsed_time());
                }
                else{
                    rps_is_init = true;
                    rps_command_torques = {0.0, 0.0, 0.0};
                }
                std::copy(rps_command_torques.begin(), rps_command_torques.end(), command_torques.begin() + 2);
            }
            else{
                // calculate anatomical command torques
                command_torques[0] = meii.anatomical_joint_pd_controllers_[0].calculate(ref[0], aj_positions[0], 0, meii[0].get_velocity());
                command_torques[1] = meii.anatomical_joint_pd_controllers_[1].calculate(ref[1], aj_positions[1], 0, meii[1].get_velocity());
                for (std::size_t i = 0; i < meii.N_qs_; ++i) {
                    rps_command_torques[i] = meii.anatomical_joint_pd_controllers_[i + 2].calculate(ref[i + 2], aj_positions[i + 2], 0, aj_velocities[i + 2]);
                }
                std::copy(rps_command_torques.begin(), rps_command_torques.end(), command_torques.begin() + 2);
            }

            // if in the no-torque setting, set all command torques to 0
            if (result.count("no_torque") > 0){
                command_torques = {0.0, 0.0, 0.0, 0.0, 0.0};
            }
            
            if (current_state == rps_init){
                // set joint level torques if we are in initialization phase
                meii.set_joint_torques(command_torques);
            }
            else{
                // set anatomical command torques
                meii.set_anatomical_joint_torques(command_torques);
            }           

            // write to robot data log
            std::vector<double> robot_log_row;
            robot_log_row.push_back(timer.get_elapsed_time().as_seconds());
            robot_log_row.insert(robot_log_row.end(),aj_positions.begin(),aj_positions.end());
            robot_log_row.insert(robot_log_row.end(),command_torques.begin(),command_torques.end());
            robot_log_row.insert(robot_log_row.end(),rj_positions.begin(),rj_positions.end());
            robot_log_row.insert(robot_log_row.end(),aj_velocities.begin(),aj_velocities.end());
            robot_log_row.insert(robot_log_row.end(),rj_velocities.begin(),rj_velocities.end());
            

            robot_log.push_back(robot_log_row);

            // update all DAQ output channels
            q8.update_output();
            
            // if enough time has passed, continue to the next state, unless we are in final state. See to_state function at top of file for details
            if (current_state == rps_init){
                // check if rps mechanism is initialized
                if (rps_is_init){
                    //set platform high nonbackdriveable
                    meii.set_rps_control_mode(2);

                    LOG(Info) << "RPS Mechanism is Initialized. Press Enter to start the Desired Trajectory";

                    // get starting position from the robot
                    WayPoint initial_pos(Time::Zero, meii.get_anatomical_joint_positions());

                    // initialize endpoints moving from initial position to start of movements
                    mj.set_endpoints(initial_pos, start_pos);

                    to_state(current_state, (current_state+1), ref_traj_clock);
                }
            }
            else if (current_state == start_wait || current_state == end_wait){
                // check for enter key press
                if (Keyboard::is_key_pressed(Key::Enter)) {
                    if (current_state == end_wait){
                        stop = true;
                        break;
                    }
                    else{
                        to_state(current_state, (current_state+1), ref_traj_clock);
                    }
                }
            }            
            else{
                if(ref_traj_clock.get_elapsed_time() > state_times[current_state]){
                    // go to the next state
                    to_state(current_state, (current_state+1), ref_traj_clock);
                }                
            }

            // write data to melshares
            ms_ref.write_data(ref);
            ms_pos.write_data(aj_positions);

            // check for exit key
            if (Keyboard::is_key_pressed(Key::Escape)) {
                stop = true;
            }

            // kick watchdog
            if (!q8.watchdog.kick() || meii.any_limit_exceeded()) {
                print("Watchdog not kicked or limit exceeded");
                stop = true;
            }

            // wait for remainder of sample period
            timer.wait();
        }
        
        // disable meii and q8
        meii.disable();
        q8.disable();
    }

    csv_write_row(filepath, log_header);
    csv_append_rows(filepath, robot_log);

    std::vector<std::string> waypoint_header = {"Time (s)", "Pos 1 (rad)", "Pos 2 (rad)", "Pos 3 (rad)", "Pos 4 (rad)", "Pos 5 (rad)"};
    std::vector<std::vector<double>> waypoint_log;

    for (auto i = 0; i < full_waypoints.size(); i++){
        std::vector<double> waypoint_temp;
        waypoint_temp.push_back(full_waypoints[i].when().as_seconds());
        for (auto j = 0; j < meii.N_aj_; j++){
            waypoint_temp.push_back(full_waypoints[i].get_pos()[j]);
        }
        waypoint_log.push_back(waypoint_temp);
    }

    csv_write_row(filepath_waypoint, waypoint_header);
    csv_append_rows(filepath_waypoint, waypoint_log);

    Keyboard::clear_console_input_buffer();
    return 0;
}